const fs = require('fs');
const path = require('path');

const ROOT = process.cwd();
const INCLUDE_DIRS = ['scrolls', 'ministries', 'treaties', 'codices', 'tools'];

function walk(dir) {
  const dirPath = path.join(ROOT, dir);
  if (!fs.existsSync(dirPath)) return [];
  const entries = fs.readdirSync(dirPath, { withFileTypes: true });
  let files = [];
  for (const e of entries) {
    const full = path.join(dir, e.name);
    if (e.isDirectory()) {
      files = files.concat(walk(full));
    } else if (e.isFile() && e.name.endsWith('.html') && e.name !== 'index.html') {
      files.push(full.replace(/\\/g, '/'));
    }
  }
  return files;
}

function makeTitle(file) {
  return file
    .replace('.html', '')
    .split('/')
    .pop()
    .replace(/[-_]/g, ' ')
    .replace(/\b\w/g, l => l.toUpperCase());
}

function sectionFromPath(p) {
  const parts = p.split('/');
  return parts[0] || 'core';
}

function tagsFromPath(p) {
  const parts = p.split('/');
  const file = parts.pop().replace('.html', '');
  return [sectionFromPath(p), ...file.split('-')].map(t => t.toLowerCase());
}

function main() {
  let paths = [];
  for (const d of INCLUDE_DIRS) {
    paths = paths.concat(walk(d));
  }

  const items = paths.map(p => ({
    section: sectionFromPath(p),
    title: makeTitle(p),
    path: p,
    tags: tagsFromPath(p),
    date: '2025-01-01',
    summary: `Placeholder summary for ${makeTitle(p)}.`
  }));

  const manifest = { items };
  fs.writeFileSync(path.join(ROOT, 'manifest.json'), JSON.stringify(manifest, null, 2));
  console.log(`Generated manifest.json with ${items.length} items.`);
}

main();
