/**
 * Codex JSON Generator (Codex Kernel v2.5)
 * ---------------------------------------
 * Generates codex.json with:
 *  - Full scroll index
 *  - Kernel-aligned schema
 *  - Slugs, sections, tags, summaries
 *  - Future-proof search fields
 */

const fs = require('fs');
const path = require('path');

// Load Codex Kernel Config
const config = require('../codex.config.js');

// Output + root
const OUTPUT_FILE = 'codex.json';
const ROOT_DIR = config.basePath || '.';

// What files count as scrolls
const SUPPORTED_EXTENSIONS = ['.html', '.htm', '.md', '.pdf', '.txt'];

// Directories to skip entirely
const EXCLUDED_DIRS = [
  'node_modules',
  '.git',
  '.github',
  'assets',
  'proof',
  'dist',
  'attached_assets'
];

// Category rules (as before)
const CATEGORY_RULES = {
  Scrolls: ['scroll', 'notice', 'affidavit', 'declaration', 'proof', 'coronation'],
  Heirs: ['heir', 'queen', 'matriarch', 'omega'],
  Codices: ['codex', 'binder', 'ledger'],
  Treaties: ['treaty', 'recognition', 'embassy', 'concord'],
  Tools: ['qr', 'verify', 'hash', 'console', 'forge', 'generator', 'manifest'],
  Ministries: ['ministry'],
  Trusts: ['trust', 'fund'],
  Identity: ['passport', 'id', 'registry'],
  Index: ['index', 'directory'],
  Other: []
};

// ----------------- helpers -----------------

function categorize(filename) {
  const lower = filename.toLowerCase();
  for (const [category, keywords] of Object.entries(CATEGORY_RULES)) {
    if (keywords.some(k => lower.includes(k))) return category;
  }
  return 'Other';
}

function formatTitle(filepath) {
  const base = path.basename(filepath, path.extname(filepath));
  return base
    .replace(/[-_]/g, ' ')
    .replace(/\b(?:id|qr|pdf|md|html)\b/gi, m => m.toUpperCase())
    .replace(/\b([ivxlcdm]+)\b/gi, m => m.toUpperCase())
    .replace(/\b\w/g, c => c.toUpperCase());
}

function generateSlug(filepath) {
  return filepath
    .replace(/\.[^/.]+$/, '')
    .replace(/[^a-zA-Z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .toLowerCase();
}

function extractTagsFromPath(filepath) {
  const parts = filepath.split('/');
  return parts
    .filter(p => p && !p.includes('.'))
    .map(p => p.toLowerCase());
}

function normalizeSectionFromPathOrCategory(filePath, category) {
  // derive from top-level folder if present
  const parts = filePath.split('/');
  const first = parts[0] || '';
  const sectionCandidate = first.toLowerCase();

  if (config.sections.includes(sectionCandidate)) {
    return sectionCandidate;
  }

  // fallback: from category
  return String(category || 'other').toLowerCase();
}

// ----------------- walker -----------------

function walk(dir, fileList = []) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);

    if (entry.isDirectory()) {
      if (!EXCLUDED_DIRS.includes(entry.name) && !entry.name.startsWith('.')) {
        walk(fullPath, fileList);
      }
    } else {
      const ext = path.extname(entry.name).toLowerCase();
      if (SUPPORTED_EXTENSIONS.includes(ext)) {
        const stat = fs.statSync(fullPath);
        fileList.push({
          path: fullPath
            .replace(/\\/g, '/')
            .replace(/^\.\//, '')
            .replace(/^\.?\//, ''),
          created: stat.birthtime.toISOString(),
          modified: stat.mtime.toISOString()
        });
      }
    }
  }

  return fileList;
}

// ----------------- main -----------------

function main() {
  const files = walk(ROOT_DIR);

  const scrolls = files.map(file => {
    const title = formatTitle(file.path);
    const category = categorize(file.path);
    const section = normalizeSectionFromPathOrCategory(file.path, category);

    const tags = config.metadataDefaults.tagsFromPath
      ? extractTagsFromPath(file.path)
      : [];

    const slug = config.metadataDefaults.autoSlug
      ? generateSlug(file.path)
      : null;

    const summaryTemplate = config.metadataDefaults.summary || 'Placeholder summary for {{title}}.';
    const summary = summaryTemplate.replace('{{title}}', title);

    return {
      url: file.path,
      slug,
      title,
      section,
      category,
      summary,
      tags,
      created: file.created || config.defaultDate,
      modified: file.modified || file.created || config.defaultDate,
      version: '1.0.0',
      lang: 'en',
      status: 'active',
      image: 'https://via.placeholder.com/150/003366/e0d5b0?text=Sigil',
      // Future-proof search fields
      pinned: false,
      searchBoost: 1.0
    };
  });

  // Sort by creation date
  scrolls.sort((a, b) => new Date(a.created) - new Date(b.created));

  const codex = {
    version: '2.5.0',
    generated: new Date().toISOString(),
    meta: {
      schema: 'codex-kernel-v2.5',
      description: 'Unified Codex index generated from repository scrolls.',
      source: 'codex.config.js',
      sections: config.sections
    },
    scrolls
  };

  fs.writeFileSync(OUTPUT_FILE, JSON.stringify(codex, null, 2), 'utf8');
  console.log(`âœ… ${OUTPUT_FILE} generated with ${scrolls.length} entries.`);
}

main();
